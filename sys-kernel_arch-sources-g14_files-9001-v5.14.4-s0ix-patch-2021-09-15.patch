From a7056f48cf6be7f02cad9fa8406cd92dd8e23b10 Mon Sep 17 00:00:00 2001
From: Scott B <arglebargle@arglebargle.dev>
Date: Wed, 15 Sep 2021 03:19:12 -0700
Subject: [PATCH] v5.14.4 s0ix patch 2021-09-15

Squashed commit of the following:

commit 172a95ed32721a87abb5b865608ca52cf469da6c
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Thu Sep 9 11:19:43 2021 -0500

    platform/x86: amd-pmc: Increase the response register timeout

    There have been reports of approximately a 9% failure rate in SMU
    communication timeouts with s0i3 entry on some OEM designs.  Currently
    the design in amd-pmc is to try every 100us for up to 20ms.

    However the GPU driver which also communicates with the SMU using a
    mailbox register which the driver polls every 1us for up to 2000ms.
    In the GPU driver this was increased by commit 055162645a40 ("drm/amd/pm:
    increase time out value when sending msg to SMU")

    Increase the maximum timeout used by amd-pmc to 2000ms to match this
    behavior.

    Cc: stable@kernel.org
    Reported-by: Julian Sikorski <belegdol@gmail.com>
    BugLink: https://gitlab.freedesktop.org/drm/amd/-/issues/1629
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>

commit b53b1045fd67d18ed948ff9d54517e9bfe01ce83
Author: Scott B <28817345+foundObjects@users.noreply.github.com>
Date:   Wed Jul 21 18:10:28 2021 -0700

    DEBUG: amd-pmc smu register dump for diagnostics

    patch this per Mario's request:
    https://gitlab.freedesktop.org/drm/amd/-/issues/1629#note_1000332

commit ef5537a8e3ad810798d4296f687445d4e538e5e4
Author: Basavaraj Natikar <Basavaraj.Natikar@amd.com>
Date:   Tue Aug 31 17:36:12 2021 +0530

    pinctrl: amd: Add irq field data

    pinctrl_amd use gpiochip_get_data() to get their local state containers
    back from the gpiochip passed as amd_gpio chip data.

    Hence added irq field data to get directly using amd_gpio chip data.

    Signed-off-by: Basavaraj Natikar <Basavaraj.Natikar@amd.com>

commit 2ed2ba9e98dd6438596792b2204ffb79f850d898
Author: Basavaraj Natikar <Basavaraj.Natikar@amd.com>
Date:   Tue Aug 31 17:36:13 2021 +0530

    pinctrl: amd: Handle wake-up interrupt

    Enable/disable power management wakeup mode, which is disabled by
    default. enable_irq_wake enables wakes the system from sleep.

    Hence added enable/disable irq_wake to handle wake-up interrupt.

    Signed-off-by: Basavaraj Natikar <Basavaraj.Natikar@amd.com>

commit fa619f720d9b7ecf7c9914f9164a2d33e7c4dbad
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Tue Aug 31 11:36:19 2021 -0500

    ACPI: PM: s2idle: Run both AMD and Microsoft methods if both are supported

    It was reported that on "HP ENVY x360" that power LED does not come back
    on, certain keys like brightness controls do not work, and the fan never
    spins up, even under load.

    In analysis of the SSDT it's clear that the Microsoft UUID doesn't provide
    functional support, but rather the AMD UUID should be supporting this
    system.

    Because this is a gap in the expected logic, confirmation with internal
    team is that AMD uPEP *does* run even when Microsoft UUID present, but
    most OEM systems have adopted value of "0x3" for supported functions and
    hence nothing runs.

    Henceforth add support for running both Microsoft and AMD methods.  This
    approach will also allow the same logic on Intel systems if desired at a
    future time as well by pulling the evaluation of
    `lps0_dsm_func_mask_microsoft` out of the if block for
    `acpi_s2idle_vendor_amd`.

    BugLink: https://gitlab.freedesktop.org/drm/amd/-/issues/1691
    Reported-by: Maxwell Beck <max@ryt.one>
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>

commit a8126200ab377bbb8025ba3a60b935a485ca7602
Author: Scott B <28817345+foundObjects@users.noreply.github.com>
Date:   Tue Jul 20 23:33:01 2021 -0700

    drm/amd/pm: Add information about SMU12 firmware version

    hacky manual import of: https://lists.freedesktop.org/archives/amd-gfx/2021-July/066835.html

    This information is useful for root causing issues with S0ix.

    Signed-off-by: Mario Limonciello <mario.limonciello at amd.com>

commit aaaa4dc0eedb97a20688dbe7936bb1701118648a
Author: Scott B <28817345+foundObjects@users.noreply.github.com>
Date:   Tue Jul 20 23:31:31 2021 -0700

    drm/amd/pm: Add information about SMU11 firmware version

    hacky manual import of: https://lists.freedesktop.org/archives/amd-gfx/2021-July/066834.html

    This information is useful for root causing issues with S0ix.

    Signed-off-by: Mario Limonciello <mario.limonciello at amd.com>
---
 drivers/acpi/x86/s2idle.c                     | 67 +++++++++++--------
 .../gpu/drm/amd/pm/swsmu/smu11/smu_v11_0.c    |  3 +
 .../gpu/drm/amd/pm/swsmu/smu12/smu_v12_0.c    |  3 +
 drivers/pinctrl/pinctrl-amd.c                 | 19 ++++--
 drivers/pinctrl/pinctrl-amd.h                 |  1 +
 drivers/platform/x86/amd-pmc.c                |  3 +-
 6 files changed, 62 insertions(+), 34 deletions(-)

diff --git a/drivers/acpi/x86/s2idle.c b/drivers/acpi/x86/s2idle.c
index 3a308461246a..7d1976e5dd8b 100644
--- a/drivers/acpi/x86/s2idle.c
+++ b/drivers/acpi/x86/s2idle.c
@@ -449,25 +449,30 @@ int acpi_s2idle_prepare_late(void)
 	if (pm_debug_messages_on)
 		lpi_check_constraints();
 
-	if (lps0_dsm_func_mask_microsoft > 0) {
+	/* screen off */
+	if (lps0_dsm_func_mask > 0)
+		acpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?
+					ACPI_LPS0_SCREEN_OFF_AMD :
+					ACPI_LPS0_SCREEN_OFF,
+					lps0_dsm_func_mask, lps0_dsm_guid);
+
+	if (lps0_dsm_func_mask_microsoft > 0)
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+
+	/* lps0 entry */
+	if (lps0_dsm_func_mask > 0)
+		acpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?
+					ACPI_LPS0_ENTRY_AMD :
+					ACPI_LPS0_ENTRY,
+					lps0_dsm_func_mask, lps0_dsm_guid);
+	if (lps0_dsm_func_mask_microsoft > 0) {
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY,
+				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+		/* modern standby entry */
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_MS_ENTRY,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY,
-				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
-	} else if (acpi_s2idle_vendor_amd()) {
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF_AMD,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY_AMD,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-	} else {
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY,
-				lps0_dsm_func_mask, lps0_dsm_guid);
 	}
-
 	return 0;
 }
 
@@ -476,24 +481,30 @@ void acpi_s2idle_restore_early(void)
 	if (!lps0_device_handle || sleep_no_lps0)
 		return;
 
-	if (lps0_dsm_func_mask_microsoft > 0) {
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT,
-				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+	/* mdoern standby exit */
+	if (lps0_dsm_func_mask_microsoft > 0)
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_MS_EXIT,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+
+	/* lps0 exit */
+	if (lps0_dsm_func_mask > 0)
+		acpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?
+					ACPI_LPS0_EXIT_AMD :
+					ACPI_LPS0_EXIT,
+					lps0_dsm_func_mask, lps0_dsm_guid);
+	if (lps0_dsm_func_mask_microsoft > 0)
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT,
+				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+
+	/* screen on */
+	if (lps0_dsm_func_mask_microsoft > 0)
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
-	} else if (acpi_s2idle_vendor_amd()) {
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT_AMD,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON_AMD,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-	} else {
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-	}
+	if (lps0_dsm_func_mask > 0)
+		acpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?
+					ACPI_LPS0_SCREEN_ON_AMD :
+					ACPI_LPS0_SCREEN_ON,
+					lps0_dsm_func_mask, lps0_dsm_guid);
 }
 
 static const struct platform_s2idle_ops acpi_s2idle_ops_lps0 = {
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/smu_v11_0.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/smu_v11_0.c
index 0a5d46ac9ccd..626d7c2bdf66 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/smu_v11_0.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/smu_v11_0.c
@@ -272,6 +272,9 @@ int smu_v11_0_check_fw_version(struct smu_context *smu)
 		break;
 	}
 
+	dev_info(smu->adev->dev, "smu fw reported version = 0x%08x (%d.%d.%d)\n",
+			 smu_version, smu_major, smu_minor, smu_debug);
+
 	/*
 	 * 1. if_version mismatch is not critical as our fw is designed
 	 * to be backward compatible.
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu12/smu_v12_0.c b/drivers/gpu/drm/amd/pm/swsmu/smu12/smu_v12_0.c
index d60b8c5e8715..00ebc381a605 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu12/smu_v12_0.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu12/smu_v12_0.c
@@ -88,6 +88,9 @@ int smu_v12_0_check_fw_version(struct smu_context *smu)
 	if (smu->is_apu)
 		adev->pm.fw_version = smu_version;
 
+	dev_info(smu->adev->dev, "smu fw reported version = 0x%08x (%d.%d.%d)\n",
+			 smu_version, smu_major, smu_minor, smu_debug);
+
 	/*
 	 * 1. if_version mismatch is not critical as our fw is designed
 	 * to be backward compatible.
diff --git a/drivers/pinctrl/pinctrl-amd.c b/drivers/pinctrl/pinctrl-amd.c
index 5b764740b829..d19974aceb2e 100644
--- a/drivers/pinctrl/pinctrl-amd.c
+++ b/drivers/pinctrl/pinctrl-amd.c
@@ -445,6 +445,7 @@ static int amd_gpio_irq_set_wake(struct irq_data *d, unsigned int on)
 	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
 	struct amd_gpio *gpio_dev = gpiochip_get_data(gc);
 	u32 wake_mask = BIT(WAKE_CNTRL_OFF_S0I3) | BIT(WAKE_CNTRL_OFF_S3);
+	int err;
 
 	raw_spin_lock_irqsave(&gpio_dev->lock, flags);
 	pin_reg = readl(gpio_dev->base + (d->hwirq)*4);
@@ -457,6 +458,15 @@ static int amd_gpio_irq_set_wake(struct irq_data *d, unsigned int on)
 	writel(pin_reg, gpio_dev->base + (d->hwirq)*4);
 	raw_spin_unlock_irqrestore(&gpio_dev->lock, flags);
 
+	if (on)
+		err = enable_irq_wake(gpio_dev->irq);
+	else
+		err = disable_irq_wake(gpio_dev->irq);
+
+	if (err)
+		dev_err(&gpio_dev->pdev->dev, "failed to %s wake-up interrupt\n",
+			on ? "enable" : "disable");
+
 	return 0;
 }
 
@@ -904,7 +914,6 @@ static struct pinctrl_desc amd_pinctrl_desc = {
 static int amd_gpio_probe(struct platform_device *pdev)
 {
 	int ret = 0;
-	int irq_base;
 	struct resource *res;
 	struct amd_gpio *gpio_dev;
 	struct gpio_irq_chip *girq;
@@ -927,9 +936,9 @@ static int amd_gpio_probe(struct platform_device *pdev)
 	if (!gpio_dev->base)
 		return -ENOMEM;
 
-	irq_base = platform_get_irq(pdev, 0);
-	if (irq_base < 0)
-		return irq_base;
+	gpio_dev->irq = platform_get_irq(pdev, 0);
+	if (gpio_dev->irq < 0)
+		return gpio_dev->irq;
 
 #ifdef CONFIG_PM_SLEEP
 	gpio_dev->saved_regs = devm_kcalloc(&pdev->dev, amd_pinctrl_desc.npins,
@@ -989,7 +998,7 @@ static int amd_gpio_probe(struct platform_device *pdev)
 		goto out2;
 	}
 
-	ret = devm_request_irq(&pdev->dev, irq_base, amd_gpio_irq_handler,
+	ret = devm_request_irq(&pdev->dev, gpio_dev->irq, amd_gpio_irq_handler,
 			       IRQF_SHARED, KBUILD_MODNAME, gpio_dev);
 	if (ret)
 		goto out2;
diff --git a/drivers/pinctrl/pinctrl-amd.h b/drivers/pinctrl/pinctrl-amd.h
index 95e763424042..1d4317073654 100644
--- a/drivers/pinctrl/pinctrl-amd.h
+++ b/drivers/pinctrl/pinctrl-amd.h
@@ -98,6 +98,7 @@ struct amd_gpio {
 	struct resource         *res;
 	struct platform_device  *pdev;
 	u32			*saved_regs;
+	int			irq;
 };
 
 /*  KERNCZ configuration*/
diff --git a/drivers/platform/x86/amd-pmc.c b/drivers/platform/x86/amd-pmc.c
index 3481479a2942..6d2d3650f8b9 100644
--- a/drivers/platform/x86/amd-pmc.c
+++ b/drivers/platform/x86/amd-pmc.c
@@ -71,7 +71,7 @@
 #define AMD_CPU_ID_YC			0x14B5
 
 #define PMC_MSG_DELAY_MIN_US		100
-#define RESPONSE_REGISTER_LOOP_MAX	200
+#define RESPONSE_REGISTER_LOOP_MAX	20000
 
 #define SOC_SUBSYSTEM_IP_MAX	12
 #define DELAY_MIN_US		2000
@@ -270,6 +270,7 @@ static int amd_pmc_send_cmd(struct amd_pmc_dev *dev, bool set, u32 *data, u8 msg
 	u32 val;
 
 	mutex_lock(&dev->lock);
+	amd_pmc_dump_registers(dev);
 	/* Wait until we get a valid response */
 	rc = readx_poll_timeout(ioread32, dev->regbase + AMD_PMC_REGISTER_RESPONSE,
 				val, val != 0, PMC_MSG_DELAY_MIN_US,
-- 
2.33.0

