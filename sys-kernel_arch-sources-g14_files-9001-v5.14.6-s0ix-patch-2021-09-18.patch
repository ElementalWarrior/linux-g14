From c76d0e81f0480e7a40db872677e837ae4c8a44aa Mon Sep 17 00:00:00 2001
From: Scott B <arglebargle@arglebargle.dev>
Date: Sat, 18 Sep 2021 15:36:27 -0700
Subject: [PATCH] v5.14.6 s0ix patch 2021-09-18

Squashed commit of the following:

commit 90f4fc1b714d70c368ae7458b5c9682775a6e0e1
Author: Sanket Goswami <Sanket.Goswami@amd.com>
Date:   Thu Sep 16 18:11:30 2021 +0530

    platform/x86: amd-pmc: Check s0i3 cycle status

    As the PM firmware returns the status of the last s0i3 in the smu_metrics
    structure, the existing name "s0i3_cyclecount" seems to be a misnomer.
    Change it accordingly to "s0i3_last_entry_status".

    Signed-off-by: Sanket Goswami <Sanket.Goswami@amd.com>
    Acked-by: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>

commit 014e2fdeaf232d1c5fd1a74813f749a7a6c0f812
Author: Sanket Goswami <Sanket.Goswami@amd.com>
Date:   Thu Sep 16 18:10:02 2021 +0530

    platform/x86: amd-pmc: Export Idlemask values based on the APU

    IdleMask is the metric used by the PM firmware to know the status of each
    of the Hardware IP blocks monitored by the PM firmware.

    Knowing this value is key to get the information of s2idle suspend/resume
    status. This value is mapped to PMC scratch registers, retrieve them
    accordingly based on the CPU family and the underlying firmware support.

    Co-developed-by: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
    Signed-off-by: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
    Signed-off-by: Sanket Goswami <Sanket.Goswami@amd.com>
    Acked-by: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
    Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>

commit 50913ca2c9ffb1d07fe0f402249ae151e95e87df
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Wed Sep 15 16:52:16 2021 -0500

    ACPI: processor idle: Allow playing dead in C3

    commit 1a022e3f1be1 ("idle, x86: Allow off-lined CPU to enter
    deeper C states") originally allowed offlined CPUs to play dead
    up to ACPI C2.  Although this improves power consumption of offlined
    CPUs, it does not allow the CPUs to get into the deepest state
    on AMD platforms blocking s0i3 entry.

    BugLink: https://gitlab.freedesktop.org/drm/amd/-/issues/1708
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>

commit 949ccde94b90a5966c23d1bd286b28778b5dbf20
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Thu Sep 9 11:19:43 2021 -0500

    platform/x86: amd-pmc: Increase the response register timeout

    There have been reports of approximately a 9% failure rate in SMU
    communication timeouts with s0i3 entry on some OEM designs.  Currently
    the design in amd-pmc is to try every 100us for up to 20ms.

    However the GPU driver which also communicates with the SMU using a
    mailbox register which the driver polls every 1us for up to 2000ms.
    In the GPU driver this was increased by commit 055162645a40 ("drm/amd/pm:
    increase time out value when sending msg to SMU")

    Increase the maximum timeout used by amd-pmc to 2000ms to match this
    behavior.

    Cc: stable@kernel.org
    Reported-by: Julian Sikorski <belegdol@gmail.com>
    BugLink: https://gitlab.freedesktop.org/drm/amd/-/issues/1629
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>

commit 235b6c0ae71da1245e4cb5fcede464f629d8d1ec
Author: Scott B <28817345+foundObjects@users.noreply.github.com>
Date:   Wed Jul 21 18:10:28 2021 -0700

    DEBUG: amd-pmc smu register dump for diagnostics

    patch this per Mario's request:
    https://gitlab.freedesktop.org/drm/amd/-/issues/1629#note_1000332

commit fe0d159834023ad729170befd9cd09f82cef4471
Author: Basavaraj Natikar <Basavaraj.Natikar@amd.com>
Date:   Tue Aug 31 17:36:12 2021 +0530

    pinctrl: amd: Add irq field data

    pinctrl_amd use gpiochip_get_data() to get their local state containers
    back from the gpiochip passed as amd_gpio chip data.

    Hence added irq field data to get directly using amd_gpio chip data.

    Signed-off-by: Basavaraj Natikar <Basavaraj.Natikar@amd.com>

commit 9cf6e041f865e42514bcb8429a20c1c056d7a5ab
Author: Basavaraj Natikar <Basavaraj.Natikar@amd.com>
Date:   Tue Aug 31 17:36:13 2021 +0530

    pinctrl: amd: Handle wake-up interrupt

    Enable/disable power management wakeup mode, which is disabled by
    default. enable_irq_wake enables wakes the system from sleep.

    Hence added enable/disable irq_wake to handle wake-up interrupt.

    Signed-off-by: Basavaraj Natikar <Basavaraj.Natikar@amd.com>

commit 91f7908d258f1edc3287429b236710ee790dd217
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Tue Aug 31 11:36:19 2021 -0500

    ACPI: PM: s2idle: Run both AMD and Microsoft methods if both are supported

    It was reported that on "HP ENVY x360" that power LED does not come back
    on, certain keys like brightness controls do not work, and the fan never
    spins up, even under load.

    In analysis of the SSDT it's clear that the Microsoft UUID doesn't provide
    functional support, but rather the AMD UUID should be supporting this
    system.

    Because this is a gap in the expected logic, confirmation with internal
    team is that AMD uPEP *does* run even when Microsoft UUID present, but
    most OEM systems have adopted value of "0x3" for supported functions and
    hence nothing runs.

    Henceforth add support for running both Microsoft and AMD methods.  This
    approach will also allow the same logic on Intel systems if desired at a
    future time as well by pulling the evaluation of
    `lps0_dsm_func_mask_microsoft` out of the if block for
    `acpi_s2idle_vendor_amd`.

    BugLink: https://gitlab.freedesktop.org/drm/amd/-/issues/1691
    Reported-by: Maxwell Beck <max@ryt.one>
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>

commit 04cd8a215540e78dba7c63aeba71fc563ea4038b
Author: Scott B <28817345+foundObjects@users.noreply.github.com>
Date:   Tue Jul 20 23:33:01 2021 -0700

    drm/amd/pm: Add information about SMU12 firmware version

    hacky manual import of: https://lists.freedesktop.org/archives/amd-gfx/2021-July/066835.html

    This information is useful for root causing issues with S0ix.

    Signed-off-by: Mario Limonciello <mario.limonciello at amd.com>

commit dd4c25dc971802f3f8ccb9d21f3b4842b8894c5e
Author: Scott B <28817345+foundObjects@users.noreply.github.com>
Date:   Tue Jul 20 23:31:31 2021 -0700

    drm/amd/pm: Add information about SMU11 firmware version

    hacky manual import of: https://lists.freedesktop.org/archives/amd-gfx/2021-July/066834.html

    This information is useful for root causing issues with S0ix.

    Signed-off-by: Mario Limonciello <mario.limonciello at amd.com>
---
 drivers/acpi/processor_idle.c                 |  3 +-
 drivers/acpi/x86/s2idle.c                     | 67 ++++++++-------
 .../gpu/drm/amd/pm/swsmu/smu11/smu_v11_0.c    |  3 +
 .../gpu/drm/amd/pm/swsmu/smu12/smu_v12_0.c    |  3 +
 drivers/pinctrl/pinctrl-amd.c                 | 19 +++--
 drivers/pinctrl/pinctrl-amd.h                 |  1 +
 drivers/platform/x86/amd-pmc.c                | 84 ++++++++++++++++++-
 7 files changed, 143 insertions(+), 37 deletions(-)

diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c
index 095c8aca141e..1b6529396371 100644
--- a/drivers/acpi/processor_idle.c
+++ b/drivers/acpi/processor_idle.c
@@ -789,7 +789,8 @@ static int acpi_processor_setup_cstates(struct acpi_processor *pr)
 		state->enter = acpi_idle_enter;
 
 		state->flags = 0;
-		if (cx->type == ACPI_STATE_C1 || cx->type == ACPI_STATE_C2) {
+		if (cx->type == ACPI_STATE_C1 || cx->type == ACPI_STATE_C2
+		 || cx->type == ACPI_STATE_C3) {
 			state->enter_dead = acpi_idle_play_dead;
 			drv->safe_state_index = count;
 		}
diff --git a/drivers/acpi/x86/s2idle.c b/drivers/acpi/x86/s2idle.c
index 3a308461246a..7d1976e5dd8b 100644
--- a/drivers/acpi/x86/s2idle.c
+++ b/drivers/acpi/x86/s2idle.c
@@ -449,25 +449,30 @@ int acpi_s2idle_prepare_late(void)
 	if (pm_debug_messages_on)
 		lpi_check_constraints();
 
-	if (lps0_dsm_func_mask_microsoft > 0) {
+	/* screen off */
+	if (lps0_dsm_func_mask > 0)
+		acpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?
+					ACPI_LPS0_SCREEN_OFF_AMD :
+					ACPI_LPS0_SCREEN_OFF,
+					lps0_dsm_func_mask, lps0_dsm_guid);
+
+	if (lps0_dsm_func_mask_microsoft > 0)
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+
+	/* lps0 entry */
+	if (lps0_dsm_func_mask > 0)
+		acpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?
+					ACPI_LPS0_ENTRY_AMD :
+					ACPI_LPS0_ENTRY,
+					lps0_dsm_func_mask, lps0_dsm_guid);
+	if (lps0_dsm_func_mask_microsoft > 0) {
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY,
+				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+		/* modern standby entry */
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_MS_ENTRY,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY,
-				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
-	} else if (acpi_s2idle_vendor_amd()) {
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF_AMD,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY_AMD,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-	} else {
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY,
-				lps0_dsm_func_mask, lps0_dsm_guid);
 	}
-
 	return 0;
 }
 
@@ -476,24 +481,30 @@ void acpi_s2idle_restore_early(void)
 	if (!lps0_device_handle || sleep_no_lps0)
 		return;
 
-	if (lps0_dsm_func_mask_microsoft > 0) {
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT,
-				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+	/* mdoern standby exit */
+	if (lps0_dsm_func_mask_microsoft > 0)
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_MS_EXIT,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+
+	/* lps0 exit */
+	if (lps0_dsm_func_mask > 0)
+		acpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?
+					ACPI_LPS0_EXIT_AMD :
+					ACPI_LPS0_EXIT,
+					lps0_dsm_func_mask, lps0_dsm_guid);
+	if (lps0_dsm_func_mask_microsoft > 0)
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT,
+				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+
+	/* screen on */
+	if (lps0_dsm_func_mask_microsoft > 0)
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
-	} else if (acpi_s2idle_vendor_amd()) {
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT_AMD,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON_AMD,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-	} else {
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON,
-				lps0_dsm_func_mask, lps0_dsm_guid);
-	}
+	if (lps0_dsm_func_mask > 0)
+		acpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?
+					ACPI_LPS0_SCREEN_ON_AMD :
+					ACPI_LPS0_SCREEN_ON,
+					lps0_dsm_func_mask, lps0_dsm_guid);
 }
 
 static const struct platform_s2idle_ops acpi_s2idle_ops_lps0 = {
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/smu_v11_0.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/smu_v11_0.c
index 0a5d46ac9ccd..626d7c2bdf66 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/smu_v11_0.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/smu_v11_0.c
@@ -272,6 +272,9 @@ int smu_v11_0_check_fw_version(struct smu_context *smu)
 		break;
 	}
 
+	dev_info(smu->adev->dev, "smu fw reported version = 0x%08x (%d.%d.%d)\n",
+			 smu_version, smu_major, smu_minor, smu_debug);
+
 	/*
 	 * 1. if_version mismatch is not critical as our fw is designed
 	 * to be backward compatible.
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu12/smu_v12_0.c b/drivers/gpu/drm/amd/pm/swsmu/smu12/smu_v12_0.c
index d60b8c5e8715..00ebc381a605 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu12/smu_v12_0.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu12/smu_v12_0.c
@@ -88,6 +88,9 @@ int smu_v12_0_check_fw_version(struct smu_context *smu)
 	if (smu->is_apu)
 		adev->pm.fw_version = smu_version;
 
+	dev_info(smu->adev->dev, "smu fw reported version = 0x%08x (%d.%d.%d)\n",
+			 smu_version, smu_major, smu_minor, smu_debug);
+
 	/*
 	 * 1. if_version mismatch is not critical as our fw is designed
 	 * to be backward compatible.
diff --git a/drivers/pinctrl/pinctrl-amd.c b/drivers/pinctrl/pinctrl-amd.c
index 5b764740b829..d19974aceb2e 100644
--- a/drivers/pinctrl/pinctrl-amd.c
+++ b/drivers/pinctrl/pinctrl-amd.c
@@ -445,6 +445,7 @@ static int amd_gpio_irq_set_wake(struct irq_data *d, unsigned int on)
 	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
 	struct amd_gpio *gpio_dev = gpiochip_get_data(gc);
 	u32 wake_mask = BIT(WAKE_CNTRL_OFF_S0I3) | BIT(WAKE_CNTRL_OFF_S3);
+	int err;
 
 	raw_spin_lock_irqsave(&gpio_dev->lock, flags);
 	pin_reg = readl(gpio_dev->base + (d->hwirq)*4);
@@ -457,6 +458,15 @@ static int amd_gpio_irq_set_wake(struct irq_data *d, unsigned int on)
 	writel(pin_reg, gpio_dev->base + (d->hwirq)*4);
 	raw_spin_unlock_irqrestore(&gpio_dev->lock, flags);
 
+	if (on)
+		err = enable_irq_wake(gpio_dev->irq);
+	else
+		err = disable_irq_wake(gpio_dev->irq);
+
+	if (err)
+		dev_err(&gpio_dev->pdev->dev, "failed to %s wake-up interrupt\n",
+			on ? "enable" : "disable");
+
 	return 0;
 }
 
@@ -904,7 +914,6 @@ static struct pinctrl_desc amd_pinctrl_desc = {
 static int amd_gpio_probe(struct platform_device *pdev)
 {
 	int ret = 0;
-	int irq_base;
 	struct resource *res;
 	struct amd_gpio *gpio_dev;
 	struct gpio_irq_chip *girq;
@@ -927,9 +936,9 @@ static int amd_gpio_probe(struct platform_device *pdev)
 	if (!gpio_dev->base)
 		return -ENOMEM;
 
-	irq_base = platform_get_irq(pdev, 0);
-	if (irq_base < 0)
-		return irq_base;
+	gpio_dev->irq = platform_get_irq(pdev, 0);
+	if (gpio_dev->irq < 0)
+		return gpio_dev->irq;
 
 #ifdef CONFIG_PM_SLEEP
 	gpio_dev->saved_regs = devm_kcalloc(&pdev->dev, amd_pinctrl_desc.npins,
@@ -989,7 +998,7 @@ static int amd_gpio_probe(struct platform_device *pdev)
 		goto out2;
 	}
 
-	ret = devm_request_irq(&pdev->dev, irq_base, amd_gpio_irq_handler,
+	ret = devm_request_irq(&pdev->dev, gpio_dev->irq, amd_gpio_irq_handler,
 			       IRQF_SHARED, KBUILD_MODNAME, gpio_dev);
 	if (ret)
 		goto out2;
diff --git a/drivers/pinctrl/pinctrl-amd.h b/drivers/pinctrl/pinctrl-amd.h
index 95e763424042..1d4317073654 100644
--- a/drivers/pinctrl/pinctrl-amd.h
+++ b/drivers/pinctrl/pinctrl-amd.h
@@ -98,6 +98,7 @@ struct amd_gpio {
 	struct resource         *res;
 	struct platform_device  *pdev;
 	u32			*saved_regs;
+	int			irq;
 };
 
 /*  KERNCZ configuration*/
diff --git a/drivers/platform/x86/amd-pmc.c b/drivers/platform/x86/amd-pmc.c
index 3481479a2942..a489f1e4d7dc 100644
--- a/drivers/platform/x86/amd-pmc.c
+++ b/drivers/platform/x86/amd-pmc.c
@@ -29,6 +29,10 @@
 #define AMD_PMC_REGISTER_RESPONSE	0x980
 #define AMD_PMC_REGISTER_ARGUMENT	0x9BC
 
+/* PMC Scratch Registers */
+#define AMD_PMC_SCRATCH_REG_CZN		0x94
+#define AMD_PMC_SCRATCH_REG_YC		0xD14
+
 /* Base address of SMU for mapping physical address to virtual address */
 #define AMD_PMC_SMU_INDEX_ADDRESS	0xB8
 #define AMD_PMC_SMU_INDEX_DATA		0xBC
@@ -71,7 +75,7 @@
 #define AMD_CPU_ID_YC			0x14B5
 
 #define PMC_MSG_DELAY_MIN_US		100
-#define RESPONSE_REGISTER_LOOP_MAX	200
+#define RESPONSE_REGISTER_LOOP_MAX	20000
 
 #define SOC_SUBSYSTEM_IP_MAX	12
 #define DELAY_MIN_US		2000
@@ -110,6 +114,10 @@ struct amd_pmc_dev {
 	u32 base_addr;
 	u32 cpu_id;
 	u32 active_ips;
+/* SMU version information */
+	u16 major;
+	u16 minor;
+	u16 rev;
 	struct device *dev;
 	struct mutex lock; /* generic mutex lock */
 #if IS_ENABLED(CONFIG_DEBUG_FS)
@@ -133,7 +141,7 @@ static inline void amd_pmc_reg_write(struct amd_pmc_dev *dev, int reg_offset, u3
 struct smu_metrics {
 	u32 table_version;
 	u32 hint_count;
-	u32 s0i3_cyclecount;
+	u32 s0i3_last_entry_status;
 	u32 timein_s0i2;
 	u64 timeentering_s0i3_lastcapture;
 	u64 timeentering_s0i3_totaltime;
@@ -162,7 +170,8 @@ static int smu_fw_info_show(struct seq_file *s, void *unused)
 	seq_puts(s, "\n=== SMU Statistics ===\n");
 	seq_printf(s, "Table Version: %d\n", table.table_version);
 	seq_printf(s, "Hint Count: %d\n", table.hint_count);
-	seq_printf(s, "S0i3 Cycle Count: %d\n", table.s0i3_cyclecount);
+	seq_printf(s, "Last S0i3 Status: %s\n", table.s0i3_last_entry_status ? "Success" :
+		   "Unknown/Fail");
 	seq_printf(s, "Time (in us) to S0i3: %lld\n", table.timeentering_s0i3_lastcapture);
 	seq_printf(s, "Time (in us) in S0i3: %lld\n", table.timein_s0i3_lastcapture);
 
@@ -201,6 +210,66 @@ static int s0ix_stats_show(struct seq_file *s, void *unused)
 }
 DEFINE_SHOW_ATTRIBUTE(s0ix_stats);
 
+static int amd_pmc_get_smu_version(struct amd_pmc_dev *dev)
+{
+	int rc;
+	u32 val;
+
+	rc = amd_pmc_send_cmd(dev, 0, &val, SMU_MSG_GETSMUVERSION, 1);
+	if (rc)
+		return rc;
+
+	dev->major = (val >> 16) & GENMASK(15, 0);
+	dev->minor = (val >> 8) & GENMASK(7, 0);
+	dev->rev = (val >> 0) & GENMASK(7, 0);
+
+	dev_dbg(dev->dev, "SMU version is %u.%u.%u\n", dev->major, dev->minor, dev->rev);
+
+	return 0;
+}
+
+static int amd_pmc_idlemask_read(struct amd_pmc_dev *pdev, struct device *dev,
+				 struct seq_file *s)
+{
+	u32 val;
+
+	switch (pdev->cpu_id) {
+	case AMD_CPU_ID_CZN:
+		val = amd_pmc_reg_read(pdev, AMD_PMC_SCRATCH_REG_CZN);
+		break;
+	case AMD_CPU_ID_YC:
+		val = amd_pmc_reg_read(pdev, AMD_PMC_SCRATCH_REG_YC);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (dev)
+		dev_dbg(pdev->dev, "SMU idlemask s0i3: 0x%x\n", val);
+
+	if (s)
+		seq_printf(s, "SMU idlemask : 0x%x\n", val);
+
+	return 0;
+}
+
+static int amd_pmc_idlemask_show(struct seq_file *s, void *unused)
+{
+	struct amd_pmc_dev *dev = s->private;
+	int rc;
+
+	if (dev->major > 56 || (dev->major >= 55 && dev->minor >= 37)) {
+		rc = amd_pmc_idlemask_read(dev, NULL, s);
+		if (rc)
+			return rc;
+	} else {
+		seq_puts(s, "Unsupported SMU version for Idlemask\n");
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(amd_pmc_idlemask);
+
 static void amd_pmc_dbgfs_unregister(struct amd_pmc_dev *dev)
 {
 	debugfs_remove_recursive(dev->dbgfs_dir);
@@ -213,6 +282,8 @@ static void amd_pmc_dbgfs_register(struct amd_pmc_dev *dev)
 			    &smu_fw_info_fops);
 	debugfs_create_file("s0ix_stats", 0644, dev->dbgfs_dir, dev,
 			    &s0ix_stats_fops);
+	debugfs_create_file("amd_pmc_idlemask", 0644, dev->dbgfs_dir, dev,
+			    &amd_pmc_idlemask_fops);
 }
 #else
 static inline void amd_pmc_dbgfs_register(struct amd_pmc_dev *dev)
@@ -270,6 +341,7 @@ static int amd_pmc_send_cmd(struct amd_pmc_dev *dev, bool set, u32 *data, u8 msg
 	u32 val;
 
 	mutex_lock(&dev->lock);
+	amd_pmc_dump_registers(dev);
 	/* Wait until we get a valid response */
 	rc = readx_poll_timeout(ioread32, dev->regbase + AMD_PMC_REGISTER_RESPONSE,
 				val, val != 0, PMC_MSG_DELAY_MIN_US,
@@ -349,6 +421,8 @@ static int __maybe_unused amd_pmc_suspend(struct device *dev)
 	amd_pmc_send_cmd(pdev, 0, NULL, SMU_MSG_LOG_RESET, 0);
 	amd_pmc_send_cmd(pdev, 0, NULL, SMU_MSG_LOG_START, 0);
 
+	/* Dump the IdleMask before we send hint to SMU */
+	amd_pmc_idlemask_read(pdev, dev, NULL);
 	msg = amd_pmc_get_os_hint(pdev);
 	rc = amd_pmc_send_cmd(pdev, 1, NULL, msg, 0);
 	if (rc)
@@ -371,6 +445,9 @@ static int __maybe_unused amd_pmc_resume(struct device *dev)
 	if (rc)
 		dev_err(pdev->dev, "resume failed\n");
 
+	/* Dump the IdleMask to see the blockers */
+	amd_pmc_idlemask_read(pdev, dev, NULL);
+
 	return 0;
 }
 
@@ -457,6 +534,7 @@ static int amd_pmc_probe(struct platform_device *pdev)
 	if (err)
 		dev_err(dev->dev, "SMU debugging info not supported on this platform\n");
 
+	amd_pmc_get_smu_version(dev);
 	platform_set_drvdata(pdev, dev);
 	amd_pmc_dbgfs_register(dev);
 	return 0;
-- 
2.33.0

