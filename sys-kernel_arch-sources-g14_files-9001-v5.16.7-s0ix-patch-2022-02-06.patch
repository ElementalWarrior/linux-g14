From 5f5cb7674868bd88b006a7e7fe27b1ae06564fab Mon Sep 17 00:00:00 2001
From: Scott B <arglebargle@arglebargle.dev>
Date: Sun, 6 Feb 2022 08:23:45 -0800
Subject: [PATCH] v5.16.7 s0ix patch 2022-02-06

Squashed commit of the following:

commit f3c791e4c2d833bff9f2e36c65cf86dcdb0cb2be
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Fri Jan 28 14:35:03 2022 -0600

    ACPI: PM: Revert "Only mark EC GPE for wakeup on Intel systems"

    Testing on various upcoming OEM systems shows commit 7b167c4cb48e ("ACPI:
    PM: Only mark EC GPE for wakeup on Intel systems") was short
    sighted and the symptoms were indicative of other problems. Some OEMs
    do have the dedicated GPIOs for the power button but also rely upon
    an interrupt to the EC SCI to let the lid work.

    The original commit showed spurious activity on Lenovo systems:
         * On both Lenovo T14 and P14s the keyboard wakeup doesn't work, and
           sometimes the power button event doesn't work.

    This was confirmed on my end at that time.

    However further development in the kernel showed that the issue was
    actually the IRQ for the GPIO controller was also shared with the EC SCI.
    This was actually fixed by commit 2d54067fcd23 ("pinctrl: amd: Fix
    wakeups when IRQ is shared with SCI").

    The original commit also showed problems with AC adapter:
         * On HP 635 G7 detaching or attaching AC during suspend will cause
           the system not to wakeup
         * On Asus vivobook to prevent detaching AC causing resume problems
         * On Lenovo 14ARE05 to prevent detaching AC causing resume problems
         * On HP ENVY x360  to prevent detaching AC causing resume problems

    Detaching AC adapter causing problems appears to have been a problem
    because the EC SCI went off to notify the OS of the power adapter change
    but the SCI was ignored and there was no other way to wake up this system
    since GPIO controller wasn't properly enabled.  The wakeups were fixed by
    enabling the GPIO controller in commit acd47b9f28e5 ("pinctrl: amd: Handle
    wake-up interrupt").

    I've confirmed on a variety of OEM notebooks with the following test
    1) echo 1 | sudo tee /sys/power/pm_debug_messages
    2) sudo systemctl suspend
    3) unplug AC adapter, make sure system is still asleep
    4) wake system from lid (which is provided by ACPI SCI on some of them)
    5) dmesg
       a) see the EC GPE dispatched, timekeeping for X seconds (matching ~time
          until AC adapter plug out)
       b) see timekeeping for Y seconds until woke (matching ~time from AC
          adapter until lid event)
    6) Look at /sys/kernel/debug/amd_pmc/s0ix_stats
       "Time (in us) in S0i3" = X + Y - firmware processing time

    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>

commit df72bede074bbc141844f5f51f066a6f2c458bfe
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Tue Jan 25 21:37:57 2022 -0600

    drm/amd: Only run s3 or s0ix if system is configured properly

    This will cause misconfigured systems to not run the GPU suspend
    routines.

    * In APUs that are properly configured system will go into s2idle.
    * In APUs that are intended to be S3 but user selects
      s2idle the GPU will stay fully powered for the suspend.
    * In APUs that are intended to be s2idle and system misconfigured
      the GPU will stay fully powered for the suspend.
    * In systems that are intended to be s2idle, but AMD dGPU is also
      present, the dGPU will go through S3

    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit f0ed760f67bc3e4ec923d94433ca2769f3cd3b5f
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Tue Jan 25 21:35:09 2022 -0600

    drm/amd: add support to check whether the system is set to s3

    This will be used to help make decisions on what to do in
    misconfigured systems.

    v2: squash in semicolon fix from Stephen Rothwell

    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit b36b3e3beef832c2524e71d086d1e4078c2b2fb8
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Tue Jan 11 14:00:26 2022 -0600

    drm/amd: Warn users about potential s0ix problems

    On some OEM setups users can configure the BIOS for S3 or S2idle.
    When configured to S3 users can still choose 's2idle' in the kernel by
    using `/sys/power/mem_sleep`.  Before commit 6dc8265f9803 ("drm/amdgpu:
    always reset the asic in suspend (v2)"), the GPU would crash.  Now when
    configured this way, the system should resume but will use more power.

    As such, adjust the `amdpu_acpi_is_s0ix function` to warn users about
    potential power consumption issues during their first attempt at
    suspending.

    Reported-by: Bjoren Dasse <bjoern.daase@gmail.com>
    Link: https://gitlab.freedesktop.org/drm/amd/-/issues/1824
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit 53c19406a39b9b844e07a294378bbfb5a9225a03
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Thu Jan 20 11:44:39 2022 -0600

    platform/x86: amd-pmc: Correct usage of SMU version

    Yellow carp has been outputting versions like `1093.24.0`, but this
    is supposed to be 69.24.0. That is the MSB is being interpreted
    incorrectly.

    The MSB is not part of the major version, but has generally been
    treated that way thus far.  It's actually the program, and used to
    distinguish between two programs from a similar family but different
    codebase.

    Link: https://patchwork.freedesktop.org/patch/469993/
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>

commit 7fbc44f24be8f364edc4f01b6569401219e83b10
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Jan 17 12:26:43 2022 +0100

    platform/x86: amd-pmc: Make amd_pmc_stb_debugfs_fops static

    amd_pmc_stb_debugfs_fops is not used outside of amd-pmc.c, make it
    static.

    Cc: Sanket Goswami <Sanket.Goswami@amd.com>
    Reported-by: kernel test robot <lkp@intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20220117112644.260168-1-hdegoede@redhat.com

commit 5793d7813afd07e2cb45780b47bd2c869e82226f
Author: Sanket Goswami <Sanket.Goswami@amd.com>
Date:   Tue Nov 30 16:53:18 2021 +0530

    platform/x86: amd-pmc: Add support for AMD Smart Trace Buffer (v6)

    STB (Smart Trace Buffer), is a debug trace buffer that isolates the
    failures by analyzing the last running feature of a system. This
    non-intrusive way always runs in the background and stores the trace
    into the SoC.

    This patch enables the STB feature by passing module param
    "enable_stb=1" while loading the driver and provides mechanism to
    access the STB buffer using the read and write routines.

    Co-developed-by: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
    Signed-off-by: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
    Signed-off-by: Sanket Goswami <Sanket.Goswami@amd.com>

commit a6897921263a5e6aaebde1c0f12d5d6b1177de05
Author: Sanket Goswami <Sanket.Goswami@amd.com>
Date:   Tue Nov 30 16:53:17 2021 +0530

    platform/x86: amd-pmc: Simplify error handling and store the pci_dev in amd_pmc_dev structure

    Handle error-exits in the amd_pmc_probe() to avoid duplication and store
    the root port information in amd_pmc_probe() so that the information
    can be used across multiple routines.

    Suggested-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Sanket Goswami <Sanket.Goswami@amd.com>

commit 9dd91c0219edc10355db5ac1932b3f751f19cca2
Author: Julian Sikorski <belegdol+github@gmail.com>
Date:   Fri Nov 19 17:52:36 2021 +0100

    GFXOFF check patch by Lijo Lazar

commit 4b88677245a652a57916571368d564bdc861a97c
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Fri Sep 24 12:32:06 2021 -0500

    ACPI: PM: s2idle: Don't report missing devices as failing constraints

    ACPI tables may have entries for devices that are not physically
    present but that can be connected.  These devices shouldn't cause
    constraints checking to fail.

    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
    Change-Id: I34f5ca978aab69ff0a0906191eec21649b19fe27

commit 42b18ef79bd4f0cc6aa587960416f0b6c1237e9e
Author: Mario Limonciello <mario.limonciello@amd.com>
Date:   Tue Jan 25 21:46:58 2022 -0600

    drm/amd: avoid suspend on dGPUs w/ s2idle support when runtime PM enabled

    commit e55a3aea418269266d84f426b3bd70794d3389c8 upstream.

    dGPUs connected to Intel systems configured for suspend to idle
    will not have the power rails cut at suspend and resetting the GPU
    may lead to problematic behaviors.

    Fixes: e25443d2765f4 ("drm/amdgpu: add a dev_pm_ops prepare callback (v2)")
    Link: https://gitlab.freedesktop.org/drm/amd/-/issues/1879
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 969cab85432996249fa5bd0fb381965b5c3078f0
Author: Aun-Ali Zaidi <admin@kodeit.net>
Date:   Sat Jan 29 05:49:55 2022 +0000

    drm/amd/display: Force link_rate as LINK_RATE_RBR2 for 2018 15" Apple Retina panels

    commit 30fbce374745a9c6af93c775a5ac49a97f822fda upstream.

    The eDP link rate reported by the DP_MAX_LINK_RATE dpcd register (0xa) is
    contradictory to the highest rate supported reported by
    EDID (0xc = LINK_RATE_RBR2). The effects of this compounded with commit
    '4a8ca46bae8a ("drm/amd/display: Default max bpc to 16 for eDP")' results
    in no display modes being found and a dark panel.

    For now, simply force the maximum supported link rate for the eDP attached
    2018 15" Apple Retina panels.

    Additionally, we must also check the firmware revision since the device ID
    reported by the DPCD is identical to that of the more capable 16,1,
    incorrectly quirking it. We also use said firmware check to quirk the
    refreshed 15,1 models with Vega graphics as they use a slightly newer
    firmware version.

    Tested-by: Aun-Ali Zaidi <admin@kodeit.net>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Aun-Ali Zaidi <admin@kodeit.net>
    Signed-off-by: Aditya Garg <gargaditya08@live.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a3d3329db088eb01a471758b39f6f353ecb90a51
Author: Paul Hsieh <paul.hsieh@amd.com>
Date:   Fri Jan 28 22:03:57 2022 +0800

    drm/amd/display: watermark latencies is not enough on DCN31

    commit f5fa54f45ab41cbb1f99b1208f49554132ffb207 upstream.

    [Why]
    The original latencies were causing underflow in some modes.
    Resolution: 2880x1620@60p when HDR enable

    [How]
    1. Replace with the up-to-date watermark values based on new measurments
    2. Correct the ddr_wm_table name to DDR5 on DCN31

    Tested-by: Daniel Wheeler <daniel.wheeler@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Stylon Wang <stylon.wang@amd.com>
    Signed-off-by: Paul Hsieh <paul.hsieh@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1f4332398c108054c1fc0890bffb2a1d36a3de8b
Author: Agustin Gutierrez <agustin.gutierrez@amd.com>
Date:   Fri Jan 28 17:51:53 2022 -0500

    drm/amd/display: Update watermark values for DCN301

    commit 2d8ae25d233767171942a9fba5fd8f4a620996be upstream.

    [Why]
    There is underflow / visual corruption DCN301, for high
    bandwidth MST DSC configurations such as 2x1440p144 or 2x4k60.

    [How]
    Use up-to-date watermark values for DCN301.

    Reviewed-by: Zhan Liu <zhan.liu@amd.com>
    Signed-off-by: Agustin Gutierrez <agustin.gutierrez@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 09070963edf1791c16d42bbdb2ec24dd394b3259
Author: Evan Quan <evan.quan@amd.com>
Date:   Mon Jan 24 13:40:35 2022 +0800

    drm/amd/pm: correct the MGpuFanBoost support for Beige Goby

    commit 3ec5586b4699cfb75cdfa09425e11d121db40773 upstream.

    The existing way cannot handle Beige Goby well as a different
    PPTable data structure(PPTable_beige_goby_t instead of PPTable_t)
    is used there.

    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 910123e23f56fe4c6f8854102b631ac11f52242c
Author: Lang Yu <Lang.Yu@amd.com>
Date:   Fri Jan 28 18:24:53 2022 +0800

    drm/amdgpu: fix a potential GPU hang on cyan skillfish

    commit bca52455a3c07922ee976714b00563a13a29ab15 upstream.

    We observed a GPU hang when querying GMC CG state(i.e.,
    cat amdgpu_pm_info) on cyan skillfish. Acctually, cyan
    skillfish doesn't support any CG features.

    Just prevent it from accessing GMC CG registers.

    Signed-off-by: Lang Yu <Lang.Yu@amd.com>
    Reviewed-by: Lijo Lazar <lijo.lazar@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
---
 drivers/acpi/x86/s2idle.c                     |  18 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu.h           |  10 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c      |  37 +++-
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c       |  11 +-
 drivers/gpu/drm/amd/amdgpu/gmc_v10_0.c        |   3 +
 .../display/dc/clk_mgr/dcn301/vg_clk_mgr.c    |  16 +-
 .../display/dc/clk_mgr/dcn31/dcn31_clk_mgr.c  |  20 +-
 .../gpu/drm/amd/display/dc/core/dc_link_dp.c  |  20 ++
 drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c     |   5 +-
 .../amd/pm/swsmu/smu11/sienna_cichlid_ppt.c   |   6 +-
 drivers/platform/x86/amd-pmc.c                | 185 ++++++++++++++++--
 11 files changed, 272 insertions(+), 59 deletions(-)

diff --git a/drivers/acpi/x86/s2idle.c b/drivers/acpi/x86/s2idle.c
index 1c48358b43ba..374aa2e8203f 100644
--- a/drivers/acpi/x86/s2idle.c
+++ b/drivers/acpi/x86/s2idle.c
@@ -309,6 +309,12 @@ static void lpi_check_constraints(void)
 			continue;
 		}
 
+		if (!acpi_get_first_physical_node(adev)) {
+			acpi_handle_debug(handle, "LPI: Device is not physically present\n");
+			lpi_constraints_table[i].handle = NULL;
+			continue;
+		}
+
 		if (adev->power.state < lpi_constraints_table[i].min_dstate)
 			acpi_handle_info(handle,
 				"LPI: Constraint not met; min power state:%s current power state:%s\n",
@@ -424,15 +430,11 @@ static int lps0_device_attach(struct acpi_device *adev,
 		mem_sleep_current = PM_SUSPEND_TO_IDLE;
 
 	/*
-	 * Some Intel based LPS0 systems, like ASUS Zenbook UX430UNR/i7-8550U don't
-	 * use intel-hid or intel-vbtn but require the EC GPE to be enabled while
-	 * suspended for certain wakeup devices to work, so mark it as wakeup-capable.
-	 *
-	 * Only enable on !AMD as enabling this universally causes problems for a number
-	 * of AMD based systems.
+	 * Some LPS0 systems, like ASUS Zenbook UX430UNR/i7-8550U, require the
+	 * EC GPE to be enabled while suspended for certain wakeup devices to
+	 * work, so mark it as wakeup-capable.
 	 */
-	if (!acpi_s2idle_vendor_amd())
-		acpi_ec_mark_gpe_for_wake();
+	acpi_ec_mark_gpe_for_wake();
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index 7d67aec6f4a2..f59121ec2648 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
@@ -1406,12 +1406,10 @@ int amdgpu_acpi_smart_shift_update(struct drm_device *dev, enum amdgpu_ss ss_sta
 int amdgpu_acpi_pcie_notify_device_ready(struct amdgpu_device *adev);
 
 void amdgpu_acpi_get_backlight_caps(struct amdgpu_dm_backlight_caps *caps);
-bool amdgpu_acpi_is_s0ix_active(struct amdgpu_device *adev);
 void amdgpu_acpi_detect(void);
 #else
 static inline int amdgpu_acpi_init(struct amdgpu_device *adev) { return 0; }
 static inline void amdgpu_acpi_fini(struct amdgpu_device *adev) { }
-static inline bool amdgpu_acpi_is_s0ix_active(struct amdgpu_device *adev) { return false; }
 static inline void amdgpu_acpi_detect(void) { }
 static inline bool amdgpu_acpi_is_power_shift_control_supported(void) { return false; }
 static inline int amdgpu_acpi_power_shift_control(struct amdgpu_device *adev,
@@ -1420,6 +1418,14 @@ static inline int amdgpu_acpi_smart_shift_update(struct drm_device *dev,
 						 enum amdgpu_ss ss_state) { return 0; }
 #endif
 
+#if defined(CONFIG_ACPI) && defined(CONFIG_SUSPEND)
+bool amdgpu_acpi_is_s3_active(struct amdgpu_device *adev);
+bool amdgpu_acpi_is_s0ix_active(struct amdgpu_device *adev);
+#else
+static inline bool amdgpu_acpi_is_s0ix_active(struct amdgpu_device *adev) { return false; }
+static inline bool amdgpu_acpi_is_s3_active(struct amdgpu_device *adev) { return false; }
+#endif
+
 int amdgpu_cs_find_mapping(struct amdgpu_cs_parser *parser,
 			   uint64_t addr, struct amdgpu_bo **bo,
 			   struct amdgpu_bo_va_mapping **mapping);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c
index 4811b0faafd9..0e12315fa0cb 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c
@@ -1031,6 +1031,20 @@ void amdgpu_acpi_detect(void)
 	}
 }
 
+#if IS_ENABLED(CONFIG_SUSPEND)
+/**
+ * amdgpu_acpi_is_s3_active
+ *
+ * @adev: amdgpu_device_pointer
+ *
+ * returns true if supported, false if not.
+ */
+bool amdgpu_acpi_is_s3_active(struct amdgpu_device *adev)
+{
+	return !(adev->flags & AMD_IS_APU) ||
+		(pm_suspend_target_state == PM_SUSPEND_MEM);
+}
+
 /**
  * amdgpu_acpi_is_s0ix_active
  *
@@ -1040,11 +1054,24 @@ void amdgpu_acpi_detect(void)
  */
 bool amdgpu_acpi_is_s0ix_active(struct amdgpu_device *adev)
 {
-#if IS_ENABLED(CONFIG_AMD_PMC) && IS_ENABLED(CONFIG_SUSPEND)
-	if (acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0) {
-		if (adev->flags & AMD_IS_APU)
-			return pm_suspend_target_state == PM_SUSPEND_TO_IDLE;
+	if (!(adev->flags & AMD_IS_APU) ||
+	    (pm_suspend_target_state != PM_SUSPEND_TO_IDLE))
+		return false;
+
+	if (!(acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0)) {
+		dev_warn_once(adev->dev,
+			      "Power consumption will be higher as BIOS has not been configured for suspend-to-idle.\n"
+			      "To use suspend-to-idle change the sleep mode in BIOS setup.\n");
+		return false;
 	}
-#endif
+
+#if !IS_ENABLED(CONFIG_AMD_PMC)
+	dev_warn_once(adev->dev,
+		      "Power consumption will be higher as the kernel has not been compiled with CONFIG_AMD_PMC.\n");
 	return false;
+#else
+	return true;
+#endif /* CONFIG_AMD_PMC */
 }
+
+#endif /* CONFIG_SUSPEND */
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index f999638a04ed..ab3851c26f71 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
@@ -2236,13 +2236,20 @@ static void amdgpu_drv_delayed_reset_work_handler(struct work_struct *work)
 static int amdgpu_pmops_prepare(struct device *dev)
 {
 	struct drm_device *drm_dev = dev_get_drvdata(dev);
+	struct amdgpu_device *adev = drm_to_adev(drm_dev);
 
 	/* Return a positive number here so
 	 * DPM_FLAG_SMART_SUSPEND works properly
 	 */
 	if (amdgpu_device_supports_boco(drm_dev))
-		return pm_runtime_suspended(dev) &&
-			pm_suspend_via_firmware();
+		return pm_runtime_suspended(dev);
+
+	/* if we will not support s3 or s2i for the device
+	 *  then skip suspend
+	 */
+	if (!amdgpu_acpi_is_s0ix_active(adev) &&
+	    !amdgpu_acpi_is_s3_active(adev))
+		return 1;
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v10_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v10_0.c
index 61ec6145bbb1..614c1362a21d 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v10_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v10_0.c
@@ -1147,6 +1147,9 @@ static void gmc_v10_0_get_clockgating_state(void *handle, u32 *flags)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
+	if (adev->ip_versions[GC_HWIP][0] == IP_VERSION(10, 1, 3))
+		return;
+
 	adev->mmhub.funcs->get_clockgating(adev, flags);
 
 	if (adev->ip_versions[ATHUB_HWIP][0] >= IP_VERSION(2, 1, 0))
diff --git a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn301/vg_clk_mgr.c b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn301/vg_clk_mgr.c
index 3eee32faa208..329ce4e84b83 100644
--- a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn301/vg_clk_mgr.c
+++ b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn301/vg_clk_mgr.c
@@ -582,32 +582,32 @@ static struct wm_table lpddr5_wm_table = {
 			.wm_inst = WM_A,
 			.wm_type = WM_TYPE_PSTATE_CHG,
 			.pstate_latency_us = 11.65333,
-			.sr_exit_time_us = 7.95,
-			.sr_enter_plus_exit_time_us = 9,
+			.sr_exit_time_us = 13.5,
+			.sr_enter_plus_exit_time_us = 16.5,
 			.valid = true,
 		},
 		{
 			.wm_inst = WM_B,
 			.wm_type = WM_TYPE_PSTATE_CHG,
 			.pstate_latency_us = 11.65333,
-			.sr_exit_time_us = 9.82,
-			.sr_enter_plus_exit_time_us = 11.196,
+			.sr_exit_time_us = 13.5,
+			.sr_enter_plus_exit_time_us = 16.5,
 			.valid = true,
 		},
 		{
 			.wm_inst = WM_C,
 			.wm_type = WM_TYPE_PSTATE_CHG,
 			.pstate_latency_us = 11.65333,
-			.sr_exit_time_us = 9.89,
-			.sr_enter_plus_exit_time_us = 11.24,
+			.sr_exit_time_us = 13.5,
+			.sr_enter_plus_exit_time_us = 16.5,
 			.valid = true,
 		},
 		{
 			.wm_inst = WM_D,
 			.wm_type = WM_TYPE_PSTATE_CHG,
 			.pstate_latency_us = 11.65333,
-			.sr_exit_time_us = 9.748,
-			.sr_enter_plus_exit_time_us = 11.102,
+			.sr_exit_time_us = 13.5,
+			.sr_enter_plus_exit_time_us = 16.5,
 			.valid = true,
 		},
 	}
diff --git a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn31/dcn31_clk_mgr.c b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn31/dcn31_clk_mgr.c
index 9df38e2ee4f4..ed53dcead839 100644
--- a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn31/dcn31_clk_mgr.c
+++ b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn31/dcn31_clk_mgr.c
@@ -329,38 +329,38 @@ static struct clk_bw_params dcn31_bw_params = {
 
 };
 
-static struct wm_table ddr4_wm_table = {
+static struct wm_table ddr5_wm_table = {
 	.entries = {
 		{
 			.wm_inst = WM_A,
 			.wm_type = WM_TYPE_PSTATE_CHG,
 			.pstate_latency_us = 11.72,
-			.sr_exit_time_us = 6.09,
-			.sr_enter_plus_exit_time_us = 7.14,
+			.sr_exit_time_us = 9,
+			.sr_enter_plus_exit_time_us = 11,
 			.valid = true,
 		},
 		{
 			.wm_inst = WM_B,
 			.wm_type = WM_TYPE_PSTATE_CHG,
 			.pstate_latency_us = 11.72,
-			.sr_exit_time_us = 10.12,
-			.sr_enter_plus_exit_time_us = 11.48,
+			.sr_exit_time_us = 9,
+			.sr_enter_plus_exit_time_us = 11,
 			.valid = true,
 		},
 		{
 			.wm_inst = WM_C,
 			.wm_type = WM_TYPE_PSTATE_CHG,
 			.pstate_latency_us = 11.72,
-			.sr_exit_time_us = 10.12,
-			.sr_enter_plus_exit_time_us = 11.48,
+			.sr_exit_time_us = 9,
+			.sr_enter_plus_exit_time_us = 11,
 			.valid = true,
 		},
 		{
 			.wm_inst = WM_D,
 			.wm_type = WM_TYPE_PSTATE_CHG,
 			.pstate_latency_us = 11.72,
-			.sr_exit_time_us = 10.12,
-			.sr_enter_plus_exit_time_us = 11.48,
+			.sr_exit_time_us = 9,
+			.sr_enter_plus_exit_time_us = 11,
 			.valid = true,
 		},
 	}
@@ -688,7 +688,7 @@ void dcn31_clk_mgr_construct(
 		if (ctx->dc_bios->integrated_info->memory_type == LpDdr5MemType) {
 			dcn31_bw_params.wm_table = lpddr5_wm_table;
 		} else {
-			dcn31_bw_params.wm_table = ddr4_wm_table;
+			dcn31_bw_params.wm_table = ddr5_wm_table;
 		}
 		/* Saved clocks configured at boot for debug purposes */
 		 dcn31_dump_clk_registers(&clk_mgr->base.base.boot_snapshot, &clk_mgr->base.base, &log_info);
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
index 13bc69d6b679..ccd6cdbe46f4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
@@ -4730,6 +4730,26 @@ static bool retrieve_link_cap(struct dc_link *link)
 		dp_hw_fw_revision.ieee_fw_rev,
 		sizeof(dp_hw_fw_revision.ieee_fw_rev));
 
+	/* Quirk for Apple MBP 2018 15" Retina panels: wrong DP_MAX_LINK_RATE */
+	{
+		uint8_t str_mbp_2018[] = { 101, 68, 21, 103, 98, 97 };
+		uint8_t fwrev_mbp_2018[] = { 7, 4 };
+		uint8_t fwrev_mbp_2018_vega[] = { 8, 4 };
+
+		/* We also check for the firmware revision as 16,1 models have an
+		 * identical device id and are incorrectly quirked otherwise.
+		 */
+		if ((link->dpcd_caps.sink_dev_id == 0x0010fa) &&
+		    !memcmp(link->dpcd_caps.sink_dev_id_str, str_mbp_2018,
+			     sizeof(str_mbp_2018)) &&
+		    (!memcmp(link->dpcd_caps.sink_fw_revision, fwrev_mbp_2018,
+			     sizeof(fwrev_mbp_2018)) ||
+		    !memcmp(link->dpcd_caps.sink_fw_revision, fwrev_mbp_2018_vega,
+			     sizeof(fwrev_mbp_2018_vega)))) {
+			link->reported_link_cap.link_rate = LINK_RATE_RBR2;
+		}
+	}
+
 	memset(&link->dpcd_caps.dsc_caps, '\0',
 			sizeof(link->dpcd_caps.dsc_caps));
 	memset(&link->dpcd_caps.fec_cap, '\0', sizeof(link->dpcd_caps.fec_cap));
diff --git a/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c b/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
index 9d7d64fdf410..37e83df92264 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
@@ -277,8 +277,11 @@ static int smu_dpm_set_power_gate(void *handle,
 	struct smu_context *smu = handle;
 	int ret = 0;
 
-	if (!smu->pm_enabled || !smu->adev->pm.dpm_enabled)
+	if (!smu->pm_enabled || !smu->adev->pm.dpm_enabled) {
+		WARN(true, "SMU uninitialized but power %s requested for %u!\n",
+		     gate ? "gate" : "ungate", block_type);
 		return -EOPNOTSUPP;
+	}
 
 	switch (block_type) {
 	/*
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c
index a4108025fe29..446d37320b94 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c
@@ -3681,14 +3681,14 @@ static ssize_t sienna_cichlid_get_gpu_metrics(struct smu_context *smu,
 
 static int sienna_cichlid_enable_mgpu_fan_boost(struct smu_context *smu)
 {
-	struct smu_table_context *table_context = &smu->smu_table;
-	PPTable_t *smc_pptable = table_context->driver_pptable;
+	uint16_t *mgpu_fan_boost_limit_rpm;
 
+	GET_PPTABLE_MEMBER(MGpuFanBoostLimitRpm, &mgpu_fan_boost_limit_rpm);
 	/*
 	 * Skip the MGpuFanBoost setting for those ASICs
 	 * which do not support it
 	 */
-	if (!smc_pptable->MGpuFanBoostLimitRpm)
+	if (*mgpu_fan_boost_limit_rpm == 0)
 		return 0;
 
 	return smu_cmn_send_smc_msg_with_param(smu,
diff --git a/drivers/platform/x86/amd-pmc.c b/drivers/platform/x86/amd-pmc.c
index 230593ae5d6d..61cb1d05158e 100644
--- a/drivers/platform/x86/amd-pmc.c
+++ b/drivers/platform/x86/amd-pmc.c
@@ -35,6 +35,12 @@
 #define AMD_PMC_SCRATCH_REG_CZN		0x94
 #define AMD_PMC_SCRATCH_REG_YC		0xD14
 
+/* STB Registers */
+#define AMD_PMC_STB_INDEX_ADDRESS	0xF8
+#define AMD_PMC_STB_INDEX_DATA		0xFC
+#define AMD_PMC_STB_PMI_0		0x03E30600
+#define AMD_PMC_STB_PREDEF		0xC6000001
+
 /* Base address of SMU for mapping physical address to virtual address */
 #define AMD_PMC_SMU_INDEX_ADDRESS	0xB8
 #define AMD_PMC_SMU_INDEX_DATA		0xBC
@@ -82,6 +88,7 @@
 #define SOC_SUBSYSTEM_IP_MAX	12
 #define DELAY_MIN_US		2000
 #define DELAY_MAX_US		3000
+#define FIFO_SIZE		4096
 enum amd_pmc_def {
 	MSG_TEST = 0x01,
 	MSG_OS_HINT_PCO,
@@ -117,18 +124,26 @@ struct amd_pmc_dev {
 	u32 cpu_id;
 	u32 active_ips;
 /* SMU version information */
-	u16 major;
-	u16 minor;
-	u16 rev;
+	u8 smu_program;
+	u8 major;
+	u8 minor;
+	u8 rev;
 	struct device *dev;
+	struct pci_dev *rdev;
 	struct mutex lock; /* generic mutex lock */
 #if IS_ENABLED(CONFIG_DEBUG_FS)
 	struct dentry *dbgfs_dir;
 #endif /* CONFIG_DEBUG_FS */
 };
 
+static bool enable_stb;
+module_param(enable_stb, bool, 0644);
+MODULE_PARM_DESC(enable_stb, "Enable the STB debug mechanism");
+
 static struct amd_pmc_dev pmc;
 static int amd_pmc_send_cmd(struct amd_pmc_dev *dev, u32 arg, u32 *data, u8 msg, bool ret);
+static int amd_pmc_write_stb(struct amd_pmc_dev *dev, u32 data);
+static int amd_pmc_read_stb(struct amd_pmc_dev *dev, u32 *buf);
 
 static inline u32 amd_pmc_reg_read(struct amd_pmc_dev *dev, int reg_offset)
 {
@@ -166,15 +181,61 @@ static int amd_pmc_get_smu_version(struct amd_pmc_dev *dev)
 	if (rc)
 		return rc;
 
-	dev->major = (val >> 16) & GENMASK(15, 0);
+	dev->smu_program = (val >> 24) & GENMASK(7, 0);
+	dev->major = (val >> 16) & GENMASK(7, 0);
 	dev->minor = (val >> 8) & GENMASK(7, 0);
 	dev->rev = (val >> 0) & GENMASK(7, 0);
 
-	dev_dbg(dev->dev, "SMU version is %u.%u.%u\n", dev->major, dev->minor, dev->rev);
+	dev_dbg(dev->dev, "SMU program %u version is %u.%u.%u\n",
+		dev->smu_program, dev->major, dev->minor, dev->rev);
 
 	return 0;
 }
 
+static int amd_pmc_stb_debugfs_open(struct inode *inode, struct file *filp)
+{
+	struct amd_pmc_dev *dev = filp->f_inode->i_private;
+	u32 size = FIFO_SIZE * sizeof(u32);
+	u32 *buf;
+	int rc;
+
+	buf = kzalloc(size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	rc = amd_pmc_read_stb(dev, buf);
+	if (rc) {
+		kfree(buf);
+		return rc;
+	}
+
+	filp->private_data = buf;
+	return rc;
+}
+
+static ssize_t amd_pmc_stb_debugfs_read(struct file *filp, char __user *buf, size_t size,
+					loff_t *pos)
+{
+	if (!filp->private_data)
+		return -EINVAL;
+
+	return simple_read_from_buffer(buf, size, pos, filp->private_data,
+				       FIFO_SIZE * sizeof(u32));
+}
+
+static int amd_pmc_stb_debugfs_release(struct inode *inode, struct file *filp)
+{
+	kfree(filp->private_data);
+	return 0;
+}
+
+static const struct file_operations amd_pmc_stb_debugfs_fops = {
+	.owner = THIS_MODULE,
+	.open = amd_pmc_stb_debugfs_open,
+	.read = amd_pmc_stb_debugfs_read,
+	.release = amd_pmc_stb_debugfs_release,
+};
+
 static int amd_pmc_idlemask_read(struct amd_pmc_dev *pdev, struct device *dev,
 				 struct seq_file *s)
 {
@@ -288,6 +349,10 @@ static void amd_pmc_dbgfs_register(struct amd_pmc_dev *dev)
 			    &s0ix_stats_fops);
 	debugfs_create_file("amd_pmc_idlemask", 0644, dev->dbgfs_dir, dev,
 			    &amd_pmc_idlemask_fops);
+	/* Enable STB only when the module_param is set */
+	if (enable_stb)
+		debugfs_create_file("stb_read", 0644, dev->dbgfs_dir, dev,
+				    &amd_pmc_stb_debugfs_fops);
 }
 #else
 static inline void amd_pmc_dbgfs_register(struct amd_pmc_dev *dev)
@@ -484,6 +549,13 @@ static int __maybe_unused amd_pmc_suspend(struct device *dev)
 	if (rc)
 		dev_err(pdev->dev, "suspend failed\n");
 
+	if (enable_stb)
+		rc = amd_pmc_write_stb(pdev, AMD_PMC_STB_PREDEF);
+	if (rc)	{
+		dev_err(pdev->dev, "error writing to STB\n");
+		return rc;
+	}
+
 	return rc;
 }
 
@@ -504,6 +576,14 @@ static int __maybe_unused amd_pmc_resume(struct device *dev)
 	/* Dump the IdleMask to see the blockers */
 	amd_pmc_idlemask_read(pdev, dev, NULL);
 
+	/* Write data incremented by 1 to distinguish in stb_read */
+	if (enable_stb)
+		rc = amd_pmc_write_stb(pdev, AMD_PMC_STB_PREDEF + 1);
+	if (rc)	{
+		dev_err(pdev->dev, "error writing to STB\n");
+		return rc;
+	}
+
 	return 0;
 }
 
@@ -521,6 +601,62 @@ static const struct pci_device_id pmc_pci_ids[] = {
 	{ }
 };
 
+static int amd_pmc_write_stb(struct amd_pmc_dev *dev, u32 data)
+{
+	int err;
+
+	err = pci_write_config_dword(dev->rdev, AMD_PMC_STB_INDEX_ADDRESS, AMD_PMC_STB_PMI_0);
+	if (err) {
+		dev_err(dev->dev, "failed to write addr in stb: 0x%X\n",
+			AMD_PMC_STB_INDEX_ADDRESS);
+		err = pcibios_err_to_errno(err);
+		goto err_pci_dev_put;
+	}
+
+	err = pci_write_config_dword(dev->rdev, AMD_PMC_STB_INDEX_DATA, data);
+	if (err) {
+		dev_err(dev->dev, "failed to write data in stb: 0x%X\n",
+			AMD_PMC_STB_INDEX_DATA);
+		err = pcibios_err_to_errno(err);
+		goto err_pci_dev_put;
+	}
+
+	return 0;
+
+err_pci_dev_put:
+	pci_dev_put(dev->rdev);
+	return err;
+}
+
+static int amd_pmc_read_stb(struct amd_pmc_dev *dev, u32 *buf)
+{
+	int i, err;
+
+	err = pci_write_config_dword(dev->rdev, AMD_PMC_STB_INDEX_ADDRESS, AMD_PMC_STB_PMI_0);
+	if (err) {
+		dev_err(dev->dev, "error writing addr to stb: 0x%X\n",
+			AMD_PMC_STB_INDEX_ADDRESS);
+		err = pcibios_err_to_errno(err);
+		goto err_pci_dev_put;
+	}
+
+	for (i = 0; i < FIFO_SIZE; i++) {
+		err = pci_read_config_dword(dev->rdev, AMD_PMC_STB_INDEX_DATA, buf++);
+		if (err) {
+			dev_err(dev->dev, "error reading data from stb: 0x%X\n",
+				AMD_PMC_STB_INDEX_DATA);
+			err = pcibios_err_to_errno(err);
+			goto err_pci_dev_put;
+		}
+	}
+
+	return 0;
+
+err_pci_dev_put:
+	pci_dev_put(dev->rdev);
+	return err;
+}
+
 static int amd_pmc_probe(struct platform_device *pdev)
 {
 	struct amd_pmc_dev *dev = &pmc;
@@ -534,22 +670,23 @@ static int amd_pmc_probe(struct platform_device *pdev)
 
 	rdev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(0, 0));
 	if (!rdev || !pci_match_id(pmc_pci_ids, rdev)) {
-		pci_dev_put(rdev);
-		return -ENODEV;
+		err = -ENODEV;
+		goto err_pci_dev_put;
 	}
 
 	dev->cpu_id = rdev->device;
+	dev->rdev = rdev;
 	err = pci_write_config_dword(rdev, AMD_PMC_SMU_INDEX_ADDRESS, AMD_PMC_BASE_ADDR_LO);
 	if (err) {
 		dev_err(dev->dev, "error writing to 0x%x\n", AMD_PMC_SMU_INDEX_ADDRESS);
-		pci_dev_put(rdev);
-		return pcibios_err_to_errno(err);
+		err = pcibios_err_to_errno(err);
+		goto err_pci_dev_put;
 	}
 
 	err = pci_read_config_dword(rdev, AMD_PMC_SMU_INDEX_DATA, &val);
 	if (err) {
-		pci_dev_put(rdev);
-		return pcibios_err_to_errno(err);
+		err = pcibios_err_to_errno(err);
+		goto err_pci_dev_put;
 	}
 
 	base_addr_lo = val & AMD_PMC_BASE_ADDR_HI_MASK;
@@ -557,24 +694,25 @@ static int amd_pmc_probe(struct platform_device *pdev)
 	err = pci_write_config_dword(rdev, AMD_PMC_SMU_INDEX_ADDRESS, AMD_PMC_BASE_ADDR_HI);
 	if (err) {
 		dev_err(dev->dev, "error writing to 0x%x\n", AMD_PMC_SMU_INDEX_ADDRESS);
-		pci_dev_put(rdev);
-		return pcibios_err_to_errno(err);
+		err = pcibios_err_to_errno(err);
+		goto err_pci_dev_put;
 	}
 
 	err = pci_read_config_dword(rdev, AMD_PMC_SMU_INDEX_DATA, &val);
 	if (err) {
-		pci_dev_put(rdev);
-		return pcibios_err_to_errno(err);
+		err = pcibios_err_to_errno(err);
+		goto err_pci_dev_put;
 	}
 
 	base_addr_hi = val & AMD_PMC_BASE_ADDR_LO_MASK;
-	pci_dev_put(rdev);
 	base_addr = ((u64)base_addr_hi << 32 | base_addr_lo);
 
 	dev->regbase = devm_ioremap(dev->dev, base_addr + AMD_PMC_BASE_ADDR_OFFSET,
 				    AMD_PMC_MAPPING_SIZE);
-	if (!dev->regbase)
-		return -ENOMEM;
+	if (!dev->regbase) {
+		err = -ENOMEM;
+		goto err_pci_dev_put;
+	}
 
 	mutex_init(&dev->lock);
 
@@ -583,8 +721,10 @@ static int amd_pmc_probe(struct platform_device *pdev)
 	base_addr_hi = FCH_BASE_PHY_ADDR_HIGH;
 	fch_phys_addr = ((u64)base_addr_hi << 32 | base_addr_lo);
 	dev->fch_virt_addr = devm_ioremap(dev->dev, fch_phys_addr, FCH_SSC_MAPPING_SIZE);
-	if (!dev->fch_virt_addr)
-		return -ENOMEM;
+	if (!dev->fch_virt_addr) {
+		err = -ENOMEM;
+		goto err_pci_dev_put;
+	}
 
 	/* Use SMU to get the s0i3 debug stats */
 	err = amd_pmc_setup_smu_logging(dev);
@@ -595,6 +735,10 @@ static int amd_pmc_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, dev);
 	amd_pmc_dbgfs_register(dev);
 	return 0;
+
+err_pci_dev_put:
+	pci_dev_put(rdev);
+	return err;
 }
 
 static int amd_pmc_remove(struct platform_device *pdev)
@@ -602,6 +746,7 @@ static int amd_pmc_remove(struct platform_device *pdev)
 	struct amd_pmc_dev *dev = platform_get_drvdata(pdev);
 
 	amd_pmc_dbgfs_unregister(dev);
+	pci_dev_put(dev->rdev);
 	mutex_destroy(&dev->lock);
 	return 0;
 }
-- 
2.35.1

